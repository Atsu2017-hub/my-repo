# my-repo

## shell
- ">>" 追記リダイレクト
  - echo "hello" >> file.txt : file.txtの末尾に"hello"を追記する。ファイルがなければ新規作成。
  - ">"は上書きで、file.txtの内容をすべて消してから書き込み。
- 環境変数は""で囲む(参照は${},普通の文字列と区別)。
  - トークン分割やパス名展開を防ぐため。スペースがあれば、シェルは分割された引数と認識。また、*などの特殊文字があれば、全.txtファイルが展開される。これらは特殊な意味を持つので特殊文字といわれる。
  - ""で囲むと、特殊文字を普通の文字としてと認識(シェルの仕様)。これをエスケープという。
  - ""では$,`,\以外をエスケープなので""のなかで${}(環境変数)は展開される。''はすべてエスケープするので${}(環境変数)が展開されず文字として扱われる。
  - ${{...}}は式やコンテキスト変数の評価、参照して埋め込み。
  - `|`はパイプ。左辺の標準出力を右辺の入力とする。YAMLでは`|`で以下の複数行のシェルスクリプトを実行できる。YAMLは改行入り文字列として保存し、Bashが改行までを一つのコマンドとして実行していく。

## Github CLI
- gh pr comment 13 --body "Hi from GitHub CLI"
  - プルリクエスト番号13にコメントする。
- gh pr create [flags]
  - --base
    - 指定されていなかったらブランチごとに存在する`gh-merge-base`を対象とする。それも設定されていなかったらデフォルトブランチ。
    - `git config branch.{current}.gh-merge-base {base}` (config:設定)でgh-merge-baseを設定する。
    - `git config --get branch.feature-A.gh-merge-base`で確認可能。
    - デフォルトでは、フォークリポジトリならそのフォーク元(upstream)、そうでなければそのリポジトリ自身(origin)。--repoを指定するとまた変わる。
  - --head
    - `<user>:<branch>`で指定。もしくはローカルブランチ名(追跡のリモートブランチが元になる)。
    - デフォルトはカレントブランチ(の追跡先)。
  - 例：自分のフォークから本家にPRを送るとき
    - `gh pr create --base main --head my-feature`
    - origin:自分のリモートリポジトリ、upstream:本家のリポジトリ
    - `--base main`はupstream/mainと解釈される。
    - `--head`は自分のフォークブランチ
## GitHub Actions
- github.refは仮マージしたブランチ名。これをもとに動作確認。
- concurrency:ワークフロー実行制御
  - `group: ${{ github.workflow }}-${{ github.ref }}`
  - ワークフロー名とブランチ名の組み合わせが同じであれば、同時に2つ実行しない。
    - ブランチ名を指定することで異なるプルリクエストはキャンセルされないようにしている。
    - 同じプルリクエストが複数発生する状況は、PRのheadブランチを更新したとき、GithubはPRの状態を更新し、同じ番号で新たなPRが発生し、ワークフローが起動。
  - GITHUB_OUTPUTはステップ間で共有される。各ジョブは、別の仮想マシン上で実行し、GITHUB_OUTPUTがさす特殊ファイルも異なるため、共有されない。(outputsを使う)
  - 1. GitHub Actions は、指定された OS（例：Ubuntu）で「まっさらな仮想マシン」を起動
    2. 仮想環境には最初、あなたのリポジトリのコードは まったく入っていない
    3. actions/checkout@v4 を使うと：
       1. Git コマンド（git clone 相当）を使って、
       2. あなたのリポジトリのコードを、
       3. 仮想環境の /home/runner/work/<REPO_NAME>/<REPO_NAME> にダウンロード
    4. その後、ビルドやテスト、デプロイなどの処理を実行できる
- キャッシュのrestore-keysは、keyで完全一致のキャッシュがなかった時、部分一致するキーを採用する。
  - キャッシュはGitHub内でキーとセットで保存されている。
  - actions/cacheでkeyで指定したキャッシュがまだ存在していない時、ジョブが成功するとpathに指定されたフォルダ・ファイルが保存される。
- キャッシュの保存と復元
  - 1. actions/cacheで前回保存したキャッシュがあれば仮想環境に復元。
    2. 実行
    3. ジョブが成功すると今のファイルをGitHubに保存。
  - 復元
    1. ジョブが始まると、actions/cache は指定された key に 完全一致するキャッシュを探します。
    2. 一致しなければ、restore-keys の各接頭辞を上から順に見て、部分一致するキャッシュを探します。
    3. 見つかったキャッシュは、指定された path に展開（復元）されます。
    4. この時点ではまだ保存（save）はされません。
  - 保存
    1. キャッシュはステップの 最後（成功時のみ）に保存されます。
    2. 復元時に使用したキャッシュキーが key: と完全一致していない場合のみ、新たにキャッシュを保存します。→ 同じキーで復元されたら再保存はスキップ（無駄な上書きを防ぐため）。
    3. 保存されるキャッシュは指定された path の内容。


    
## 環境変数、コンテキスト変数
- github.workspace:ソースコードが展開されるパス。例/home/runner/work/my-repo/my-repo。ジョブごとに作成。ビルド時などに使用。
  - 仮想マシン上のカレントディレクトリはここ。
  
## その他
- クレデンシャル：ID,ユーザ名、パスワードなど識別情報の総称。認証に用いる。
- git tag v1.1.0 <commit-hash>でtagを作成。<commit-hash>を省略すると現在のブランチの最新コミットにtagをつける。
- tagをpushするためにgit push origin v1.1.0。originは省略不可。

